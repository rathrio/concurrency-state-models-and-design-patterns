Series-05
=========

Rathesan Iyadurai (10-107-688)

Exercise 1
----------

Exercise 2
----------

1. One of the philosopher has to pick up the forks in reverse order. This
   breaks the waits-for cycle. Starvation is not possible, because if one
   philosopher wants the fork that is currently in use, he will be the next one
   to get it.

2. Introduce a "waiter" mutex that all philosophers have access to.
   Philosophers ask the waiter for permission to pick up both forks and the waiter
   only allows one philosopher to do so. This approach is not particularly
   fair, since one philosopher might just never get his two forks, since his
   neighbors are alternately acquiring the forks.

3. Similar to 2, but allow only n - 1 philosophers to take a seat whereas n is
   the number of forks. Philosophers that are not at the table wait in a FIFO
   queue, and philosophers at the table that are done eating go wait in the
   FIFO queue. Thus all philosophers eventually get to eat -> no one starves.

4. Chandy/Misra solution: Philosophers make their forks dirty when eating.
   Philosophers are numbered and for each neighboring pair of philosophers the one
   with the lower number gets the fork in between first. When a philosopher wants
   the fork, he asks his neighbor. The neighbor will keep his fork if it's clean,
   but if it's dirty, he'll clean it and send it over. This protocol is fair,
   since the philosophers that haven't eaten last get the forks next.


Exercise 3
----------

Introduce a "waiter" mutex:

    PHIL = (
      sitdown -> waiter.acquire -> right.get -> left.get -> eat ->
      left.put -> right.put -> arise -> waiter.release -> PHIL
    ).

    FORK = (get -> put -> FORK).

    LOCK = (acquire -> release -> LOCK).

    ||DINERS(N=5) = forall [i:0..N-1](
      phil[i]:PHIL
      ||
      phil[j:0..N-1]::waiter:LOCK
      ||
      {phil[i].left,phil[((i-1)+N)%N].right}::FORK
    ).


Exercise 4
----------

Feel free to remove any of the start options from the MAZE state, to test
different shortest paths:

    MAZE = (
        start -> S0
        |
        start -> S1
        |
        start -> S2
        |
        start -> S3
        |
        start -> S4
        |
        start -> S5
        |
        start -> S6
        |
        start -> S7
        |
        start -> S8
    ),
    S0 = (
      north -> STOP
      |
      east -> S1
    ),
    S1 = (
      east -> S2
      |
      south -> S4
      |
      west -> S0
    ),
    S2 = (
      south -> S5
      |
      west -> S1
    ),
    S3 = (
      east -> S4
      |
      south -> S6
    ),
    S4 = (
      north -> S1
      |
      west -> S3
    ),
    S5 = (
      north -> S2
      |
      south -> S8
    ),
    S6 = (
      north -> S3
    ),
    S7 = (
      east -> S8
    ),
    S8 = (
      north -> S5
      |
      west -> S7
    ).
