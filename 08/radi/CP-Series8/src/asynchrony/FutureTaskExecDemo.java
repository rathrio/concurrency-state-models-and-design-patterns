package asynchrony;import java.util.concurrent.*;public class FutureTaskExecDemo {		// How long to wait for the computation of a fibonacci value.	private final static int TIMEOUT_SECONDS = 1;		public static void main(String args[]) {		FutureTaskExecDemo.demo();	}		public static void demo() {		FutureTaskExecDemo server = new FutureTaskExecDemo();		System.out.println("Starting FutureDemo.demo()");		// With some luck, the faster ones may get computed first ...		// NB: results depend highly on Thread scheduling ...		startDemoThread(server, 45);		startDemoThread(server, 35);		startDemoThread(server, 20);		startDemoThread(server, 15);		startDemoThread(server, 5);	}		protected static void startDemoThread(final FutureTaskExecDemo server, final int n){		new Thread() {			public void run() {				try {					System.out.println("CALLING fibonacci("+n+")");					Future<Integer> future = server.service(n);					System.out.println("GOT future(fibonacci("+n+"))");										int val;					try {						val = future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS).intValue();					} catch (TimeoutException e) {						System.out.println("Took too long to calculate fibonacci("+n+")");						return;					}										System.out.println("GOT fibonacci("+n+") = " + val);					} catch(InterruptedException e) {				} catch(ExecutionException e) {				}			}		}.start();	}		private ExecutorService executor = Executors.newFixedThreadPool(5);		public Future<Integer> service (final int n) {		// unsynchronized		Callable<Integer> task = new Callable<Integer>() {			public Integer call() { return new Integer(fibonacci(n)); }		};				Future<Integer> future = executor.submit(task);		return future;	}		public static int fibonacci(int n) {		if (n<2) return 1;		else return fibonacci(n-1) + fibonacci(n-2);	}}