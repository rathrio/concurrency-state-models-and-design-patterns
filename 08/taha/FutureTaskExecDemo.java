package asynchrony;import java.util.concurrent.*;/** * This is a straightforward translation of FutureDemo * to use java.util.concurrent.FutureTask * @author oscar * */public class FutureTaskExecDemo {		public static void main(String args[]) {		FutureTaskExecDemo.demo();	}		public static void demo() {		FutureTaskExecDemo server = new FutureTaskExecDemo();		System.out.println("Starting FutureDemo.demo()");		// With some luck, the faster ones may get computed first ...		// NB: results depend highly on Thread scheduling ...		startDemoThread(server, 45);		startDemoThread(server, 35);		startDemoThread(server, 20);		startDemoThread(server, 15);		startDemoThread(server, 5);	}		protected static void startDemoThread(final FutureTaskExecDemo server, final int n){		new Thread() {			public void run() {				try {					System.out.println("CALLING fibonacci("+n+")");					FutureTask<Integer> future = server.service(n);					System.out.println("GOT future(fibonacci("+n+"))");					int val = future.get(30000, TimeUnit.MILLISECONDS).intValue();// Ex 2 c) client thread waits at most the given amount of time					System.out.println("GOT fibonacci("+n+") = " + val);				} catch(InterruptedException e) {				} catch(ExecutionException e) {				} catch (TimeoutException e) {					System.out.println("Timeout");				}			}		}.start();	}		public FutureTask<Integer> service (final int n) {		// unsynchronized		FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {			public Integer call() { return new Integer(fibonacci(n)); }		});		ExecutorService executor = Executors.newSingleThreadExecutor();		executor.execute(future); // or use an Executor		executor.shutdown();		return future;	}		public static int fibonacci(int n) {		if (n<2) return 1;		else return fibonacci(n-1) + fibonacci(n-2);	}}